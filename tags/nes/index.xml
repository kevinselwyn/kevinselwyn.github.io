<?xml-stylesheet type="text/xsl" href="#stylesheet" ?> <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><xsl:stylesheet id="stylesheet" version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" exclude-result-prefixes="xsl"><xsl:output method="html" doctype-system="about:legacy-compat"><xsl:template match="/rss"><html lang="en-us"><head><meta name="viewport" content="width=device-width,initial-scale=1"><title>nes RSS | Kevin Selwyn</title><style>body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;line-height:1.6;display:flex;flex-direction:column;min-height:100vh;margin:0;padding:0}img{max-width:100%;border-radius:.2rem}pre{overflow-x:auto;border:.1rem solid #d3d3d3;padding:1rem}code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,Courier,monospace}.Banner{list-style:none;display:flex;flex-flow:row-reverse wrap-reverse;justify-content:space-between;margin:0;padding:0}.Banner-item:nth-child(1){order:4}.Banner-item:nth-child(2){order:3}.Banner-item:nth-child(3){order:2}.Banner-item:nth-child(4){order:1}.Banner-link{font-size:1.25rem;color:#fff;padding:.5rem 1rem}.Heading{display:flex;flex-wrap:wrap;justify-content:space-between;align-items:baseline}.Heading-title{margin:1.5rem .5rem 0 0}.Heading-link{color:inherit}.Tags{list-style:none;display:flex;flex-wrap:wrap;justify-content:center;margin:1.5rem 0;padding:0}.Tags-item{border-radius:.2rem;margin:.2rem;padding:0 .3rem}.Tags-link{color:#fff}.Pagination{font-size:1.25rem;color:inherit}.Pagination--right{float:right}.Footer{text-align:center;margin:1rem 0}.u-expand{flex-grow:1}.u-wrapper{max-width:42rem;margin:auto}.u-padding{padding:0 1rem}.u-background{background:teal}.u-clickable{font-weight:700;text-decoration:none;display:inline-block}</style></head><body><nav class="u-background"><div class="u-wrapper"><ul class="Banner"><li class="Banner-item u-expand"><a class="Banner-link u-clickable" href="/">Kevin Selwyn</a></li><li class="Banner-item"><a class="Banner-link u-clickable" href="/resume/">Resume</a></li><li class="Banner-item"><a class="Banner-link u-clickable" href="/posts/">Posts</a></li><li class="Banner-item"><a class="Banner-link u-clickable" href="/tags/">Tags</a></li><li class="Banner-item"><a class="Banner-link u-clickable" href="/categories/">Categories</a></li></ul></div></nav><main class="u-expand"><div class="u-wrapper"><div class="u-padding"><h2 class="Heading-title"><a class="Heading-link u-clickable" href="/tags/nes/index.xml" rel="bookmark">nes RSS</a></h2><p>To subscribe to this RSS feed, copy its address and paste it into your favorite feed reader.</p></div></div></main></body></html></xsl:template></xsl:stylesheet><channel><title>nes on Kevin Selwyn</title><link>/tags/nes/<description>Recent content in nes on Kevin Selwyn</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastbuilddate>Thu, 21 Nov 2019 21:35:50 -0500</lastbuilddate><atom:link href="/tags/nes/index.xml" rel="self" type="application/rss+xml"><item><title>Game Genie Disassembly</title><link>/posts/game-genie-disassembly/<pubdate>Thu, 21 Nov 2019 21:35:50 -0500</pubdate><guid>/posts/game-genie-disassembly/</guid><description>&lt;blockquote&gt;NOTE: This was originally posted on a different blogging platform on April 8, 2016&lt;/blockquote&gt; &lt;p&gt;The original Game Genie is a cheat device for the Nintendo Entertainment System that alters game data in real-time. Users must &amp;ldquo;program&amp;rdquo; the Game Genie to perform certain actions. They do this by entering codes into the interface that appears before the game they wish to alter.&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;/img/posts/game-genie-disassembly/interface.png&#34; alt=&#34;Game Genie interface&#34; style=&#34;margin-right:20px; float:left;&#34; /&gt;&lt;/p&gt; &lt;p&gt;Since the interface runs on the NES, it is also written in 6502 assembly, the programming language of the Nintendo Entertainment System.&lt;/p&gt; &lt;p&gt;I undertook a disassembly of the Game Genie ROM to see just how the creators went about programming their infamous cheat device.&lt;/p&gt; &lt;p&gt;To see the full code explained here, check out the repo: &lt;a href=&#34;https://github.com/kevinselwyn/game-genie-disassembly&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://github.com/kevinselwyn/game-genie-disassembly&#34;&gt;https://github.com/kevinselwyn/game-genie-disassembly&lt;/a&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;/img/posts/game-genie-disassembly/game-genie.gif&#34; alt=&#34;Game Genie&#34; /&gt;&lt;/p&gt; &lt;p&gt;Note: My task wasn&amp;rsquo;t so much to disassemble the ROM (that part is easy), as much as it was to put the parts of the disassembled ROM in context (that part is hard).&lt;/p&gt; &lt;h2 id=&#34;the-basics-of-the-assembly&#34;&gt;The Basics of the Assembly&lt;/h2&gt; &lt;p&gt;The ROM is made up of bytes of 6502 machine code that can also be represented in assembly language. Machine code like this:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;A9 01 8D 16 40 A9 00 8D 16 40 A0 08 AD 16 40 6A 26 07 88 D0 F7 A0 08 AD 17 40 6A 26 08 88 D0 F7 60 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Can be written in assembly as:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; LDA #$01 STA $4016 LDA #$00 STA $4016 LDY #$08 LDA $4016 ROR A ROL $07 DEY BNE $F068 LDY #$08 LDA $4017 ROR A ROL $08 DEY BNE $F073 RTS &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;33 bytes of machine code translate into 17 instructions of assembly code, the latter being easier on the eyes, more concise, and simpler to debug.&lt;/p&gt; &lt;p&gt;The result is a set of instructions that contain mnemonics for CPU instructions. LDA means to &lt;b&gt;L&lt;/b&gt;oa&lt;b&gt;D&lt;/b&gt; the &lt;b&gt;A&lt;/b&gt;ccumulator register with whatever follows. Or &lt;b&gt;DE&lt;/b&gt;creasing the &lt;b&gt;Y&lt;/b&gt; register (DEY). Operands can be actual values, addresses in memory, the accumulator register itself, or have none at all (depending on the particular instruction).&lt;/p&gt; &lt;p&gt;Together, all these instructions make up the ROM and are what I will be poring over.&lt;/p&gt; &lt;h2 id=&#34;the-anatomy-of-the-rom&#34;&gt;The Anatomy of the ROM&lt;/h2&gt; &lt;p&gt;The Game Genie ROM is 24592 bytes and breaks down as follows:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;| Name | Size (bytes) | |---------|--------------| | Header | 16 | | PRG ROM | 4096 (x4) | | CHR ROM | 8192 | &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;b&gt;Header&lt;/b&gt; is 16 bytes of data that contains information useful to emulators, so will be (almost) ignored in the disassembly process.&lt;/p&gt; &lt;p&gt;The &lt;b&gt;PRG ROM&lt;/b&gt; is the actual game code. On the Game Genie, the core code is repeated 4 times. So the total size is 16384 bytes, but we are only concerned with &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; of that.&lt;/p&gt; &lt;p&gt;The &lt;b&gt;CHR ROM&lt;/b&gt; is the character data that contains graphics tiles that can be displayed in the background and in sprites.&lt;/p&gt; &lt;h2 id=&#34;the-disassembly&#34;&gt;The Disassembly&lt;/h2&gt; &lt;p&gt;The heavy lifter in the process of translating machine code into assembly code was &lt;a href=&#34;https://github.com/mnaberez/py65&#34; target=&#34;_blank&#34;&gt;py65&lt;/a&gt;, a 6502 simulator written in Python. It comes with a utility called &lt;b&gt;py65mon&lt;/b&gt;, an interactive monitor that can be used to load a ROM and disassemble it.&lt;/p&gt; &lt;p&gt;First we load it in at offset 0xBFF0. The PRG ROM starts at offset 0x10, so we account for this by loading it in at 0xC000 - 0x10. The CHR ROM is cropped off as a result, but is unneeded at this point.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;.load gamegenie.nes BFF0 ?Wrote +16400 bytes from $bff0 to $ffff PC AC XR YR SP NV-BDIZC 6502: 0000 00 00 00 ff 00110000 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;From there, it&amp;rsquo;s easy as:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;.disassemble F000:FFFF $f000 78 SEI $f001 d8 CLD $f002 a9 00 LDA #$00 ... &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;2157 lines later, and our disassembly is complete! Told you it would be easy.&lt;/p&gt; &lt;h2 id=&#34;the-graphics&#34;&gt;The Graphics&lt;/h2&gt; &lt;p&gt;The CHR ROM was recreated by looking at the PPU (Picture Processing Unit) data in an emulator. The graphics are extremely simple:&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;/img/posts/game-genie-disassembly/chr.png&#34; alt=&#34;Game Genie CHR&#34; style=&#34;margin:0 auto; display:block;&#34; /&gt;&lt;/p&gt; &lt;p&gt;This image was converted back into CHR data using a utility I wrote: &lt;a href=&#34;https://github.com/kevinselwyn/img2chr&#34; target=&#34;_blank&#34;&gt;img2chr&lt;/a&gt;.&lt;/p&gt; &lt;h2 id=&#34;the-reassembly&#34;&gt;The Reassembly&lt;/h2&gt; &lt;p&gt;I&amp;rsquo;m using a (slightly modified) version of &lt;a href=&#34;https://github.com/kevinselwyn/nesasm&#34; target=&#34;_blank&#34;&gt;nesasm&lt;/a&gt; to reassemble the ROM to see if we end up back at the same data as the source ROM.&lt;/p&gt; &lt;p&gt;&lt;i&gt;nesasm&lt;/i&gt; lets you include external source files or binary data, allowing developers to separate components of a project for greater abstraction and readability.&lt;/p&gt; &lt;p&gt;Here is our project structure:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;game-genie-disassembly/ bank.asm # Our program code to be duplicated 4 times constants.asm # Unchanging registers, values, and offsets gamegenie.asm # Main file gamegenie.png # CHR data in PNG format variables.asm # Variable aliases &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Other files are included build build purposes, but these are the files we will break the ROM into for reassembly.&lt;/p&gt; &lt;h2 id=&#34;the-breakdown&#34;&gt;The Breakdown&lt;/h2&gt; &lt;p&gt;To make things easier to read/understand, I replaced all zero-page variables ($00-$FF) with variable names (variable_00-variable_FF). This will make it easier to swap out the ambiguous variable names later when I find out what they do or what data they hold.&lt;/p&gt; &lt;p&gt;Next, I chunked the code according to a few constraints. A new block was formed if:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;A RTS instruction is found (&lt;b&gt;R&lt;/b&gt;e&lt;b&gt;T&lt;/b&gt;urn From &lt;b&gt;S&lt;/b&gt;ubroutine). That&amp;rsquo;s a pretty clear indication that the code that came before was part of a subroutine&lt;/li&gt; &lt;li&gt;A JMP instruction is found (&lt;b&gt;J&lt;/b&gt;u&lt;b&gt;MP&lt;/b&gt; to address). The chunk doesn&amp;rsquo;t necessarily come at the JMP, but rather, at the destination address.&lt;/li&gt; &lt;li&gt;Data is encountered. If instructions start to look weird, it&amp;rsquo;s a pretty good chance we found a section of data.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Let&amp;rsquo;s look at a subroutine chunk:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$f01e a2 60 LDX #$60 $f020 a0 08 LDY #$08 $f022 ca DEX $f023 d0 fd BNE $f022 $f025 88 DEY $f026 d0 fa BNE $f022 $f028 60 RTS &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Let&amp;rsquo;s clean it up and add a label before offset $F022 for the BNE (&lt;b&gt;B&lt;/b&gt;ranch on &lt;b&gt;N&lt;/b&gt;ot &lt;b&gt;E&lt;/b&gt;qual to zero) instructions:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; LDX #$60 LDY #$08 label: DEX BNE label DEY BNE label RTS &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Now, let&amp;rsquo;s look at a data chunk:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$f83a 85 63 STA $63 $f83c a5 52 LDA $52 $f83e 85 62 STA $62 $f840 68 PLA $f841 a8 TAY $f842 60 RTS $f843 19 19 19 ORA $1919,Y $f846 19 1a 19 ORA $191a,Y $f849 19 19 19 ORA $1919,Y $f84c 1a ??? $f84d 19 19 19 ORA $1919,Y $f850 19 1a 19 ORA $191a,Y $f853 19 19 19 ORA $1919,Y $f856 1a ??? &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Notice that for the first 6 lines, the instructions look normal. After that, things start to get weird. A lot of successive ORA (Logical &lt;b&gt;OR&lt;/b&gt; with &lt;b&gt;A&lt;/b&gt;ccumulator) instructions are not normal, and neither are the ??? instructions. Also, we can notice a sort of pattern in the 8 remaining (incorrectly disassembled) instructions. The instructions should look like:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; STA &amp;lt;variable_63 LDA &amp;lt;variable_52 STA &amp;lt;variable_62 PLA TAY RTS data: .db $19, $19, $19, $19 .db $1A .db $19, $19, $19, $19 .db $1A .db $19, $19, $19, $19 .db $1A .db $19, $19, $19, $19 .db $1A &lt;/code&gt;&lt;/pre&gt; &lt;h2 id=&#34;the-labeling&#34;&gt;The Labeling&lt;/h2&gt; &lt;p&gt;A great starting point in creating labels that have some context is by looking at the vectors in the ROM.&lt;/p&gt; &lt;p&gt;3 16-bit vectors occur starting at offset $FFFA:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;| Vector | Offset | |--------|--------| | NMI | $FFFA | | RESET | $FFFC | | IRQ | $FFFE | &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;When the ROM boots, the CPU looks at these vectors (mainly the RESET vector) to tell it which address to jump to in the ROM at the start of execution.&lt;/p&gt; &lt;p&gt;The NMI vector is the address the CPU jumps to during every &lt;b&gt;N&lt;/b&gt;on-&lt;b&gt;M&lt;/b&gt;askable &lt;b&gt;I&lt;/b&gt;nterrupt (usually run once every frame).&lt;/p&gt; &lt;p&gt;The IRQ vector is unused in this ROM. It is usually set to $0000 if unused, but is set to $FFFF in this case.&lt;/p&gt; &lt;p&gt;At the end of the Game Genie ROM, we have these disassembled instructions:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$fffa 7d f0 00 ADC $00f0,X $fffd f0 ff BEQ $fffe $ffff ff ??? &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If we weren&amp;rsquo;t savvy to the vector locations to begin with, the strange &amp;ldquo;instructions&amp;rdquo; here would raise a red flag. Disassembled correctly:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;NMI_vector: .db $7D, $F0 RESET_vector: .db $00, $F0 IRQ_vector: .db $FF, $FF &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;It&amp;rsquo;s worth noting that vectors (and many other 16-bit addresses are stored backwards. Meaning that the high byte appears second and the low byte first.&lt;/p&gt; &lt;p&gt;The RESET vector is actually $F000: the start of the last $1000-sized bank.&lt;/p&gt; &lt;p&gt;&lt;i&gt;nesasm&lt;/i&gt; can help us out with this by storing it as a word (16-bit value) with .dw instead of a byte (8-bit value) with .db:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;NMI_vector: .dw $F07D RESET_vector: .dw $F000 IRQ_vector: .dw $FFFF &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Much easier to read when following jumps in the source.&lt;/p&gt; &lt;h2 id=&#34;the-variables&#34;&gt;The Variables&lt;/h2&gt; &lt;p&gt;By default, all zero-page variables ($00-$FF) were named variable_00-variable_FF. The ones where I could derive context were changed. Note the following snippet:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;$f08c ad 45 00 LDA $0045 $f08f 8d 05 20 STA $2005 $f092 ad 46 00 LDA $0046 $f095 8d 05 20 STA $2005 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Based on what we know about $2005, the scroll register, it needs to be written to twice: once for the X scroll position and one more for the Y scroll position. It stands to reason that the variables right before each write to $2005 correspond to 2 variables that store those positions.&lt;/p&gt; &lt;p&gt;After rewriting:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; LDA scroll_x STA $2005 LDA scroll_y STA $2005 &lt;/code&gt;&lt;/pre&gt; &lt;h2 id=&#34;the-final-rom&#34;&gt;The Final ROM&lt;/h2&gt; &lt;p&gt;This is the entirety &lt;b&gt;gamegenie.asm&lt;/b&gt; the file that will compile into the final ROM:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; .inesprg 1 ; 1 16KB PRG ROM .ineschr 1 ; 1 8KB CHR ROM .inesmir 1 ; Vertical Mirroring .inesmap 0 ; Mapper 0 .bank 0 .org $C000 .incbin &amp;quot;bank.raw&amp;quot; .incbin &amp;quot;bank.raw&amp;quot; .bank 1 .org $E000 .incbin &amp;quot;bank.raw&amp;quot; .incbin &amp;quot;bank.raw&amp;quot; .bank 2 .org $0000 .incbin &amp;quot;gamegenie.chr&amp;quot; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The first 4 lines are iNES directives that set values in the header used for emulators:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;inesprg&lt;/b&gt; - Sets the number of 16KB PRG ROMs. In this case, only 1.&lt;/li&gt; &lt;li&gt;&lt;b&gt;ineschr&lt;/b&gt; - Sets the number of 8KB CHR ROMs. Only 1 here as well.&lt;/li&gt; &lt;li&gt;&lt;b&gt;inesmir&lt;/b&gt; - Sets the nametable mirroring. Useful for scrolling, so relatively pointless here.&lt;/li&gt; &lt;li&gt;&lt;b&gt;inesmap&lt;/b&gt; - Sets the mapper number. 0 means no memory mapper is being used.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;b&gt;bank.raw&lt;/b&gt; is included 4 times because the main source is so small and must be repeated to fill out the 1 16KB PRG ROM space. Including the source 4 times creates duplicate label errors, so nesasm is used beforehand to compile just the 4KB bank once and then it is included 4 times in the final source code to compile the final ROM.&lt;/p&gt; &lt;h2 id=&#34;final-thoughts&#34;&gt;Final Thoughts&lt;/h2&gt; &lt;blockquote&gt;&lt;i&gt;How much did you learn?&lt;/i&gt;&lt;/blockquote&gt; &lt;p&gt;Not much, really. I learned a lot about how to successfully disassemble a NES ROM, but precious little about what the code is actually doing. I managed to catch a glimmer of context at the beginning of the ROM (startup, config, etc.), but after that, it gets pretty esoteric.&lt;/p&gt; &lt;blockquote&gt;&lt;i&gt;Why did you do this?&lt;/i&gt;&lt;/blockquote&gt; &lt;p&gt;I&amp;rsquo;ve always wanted to disassemble a NES ROM. The file size is daunting, but the Game Genie ROM is small and on top of that, the main code is just repeated a few times to fill out the size. It was not very time intensive, so it&amp;rsquo;s a good starting point for larger ROMs.&lt;/p&gt; &lt;blockquote&gt;&lt;i&gt;What was the most interesting takeaway?&lt;/i&gt;&lt;/blockquote&gt; &lt;p&gt;I didn&amp;rsquo;t realize until I was almost done that, essentially, the Game Genie was an unlicensed NES game; that is, a game not made with Nintendo&amp;rsquo;s blessing. It&amp;rsquo;s amazing to see snippets of code that I&amp;rsquo;ve seen in other licensed NES games, as well as my own NES programming projects where the conventions were arrived at naturally.&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;Check out the full code in the repo here: &lt;a href=&#34;https://github.com/kevinselwyn/game-genie-disassembly&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://github.com/kevinselwyn/game-genie-disassembly&#34;&gt;https://github.com/kevinselwyn/game-genie-disassembly&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>